<head><title>Weighted Random</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#d81b60">

<link rel="stylesheet" type="text/css" href="/style/main.css">

<script src="/script/main.js"></script></head><body><header>
	<a href="/index.html" style="float: left;">Home</a>
	<a href="/feed.html" style="float: left;">Feed</a>
	<a href="/p/me.html" style="float: right;">Ajani James Bilby</a>
</header><div class="wrapper"><h1>Weighted Random</h1><p>
Weighted randoms are an important feature for any data analysis where the system does not want to flood the user with options, but at the same time, they also do not want to always show the same items.</br>
In the use case of advertising, you want to show the user the ad most appropriate for them, however, you also do not want to always show the same ad all the time; you want to keep things fresh. However you also still should show the user the most relevant item most of the time.</br></p><p>
This is where weighted random systems come into play; they allow you to show the best answer the majority of the time while still occasionally showing other relevant content. Doing this can actually be good for the system because it can allow the eco-system to discover new trends and remove some feedback loops that might develop otherwise in adaptive recommendation systems.</br>
For instance, if the same ad always shows to the same user, and then click on it multiple times it will reinforce the same choice, thus it will display on other peoples recommendations, and the reinforcement will continue. However, it is never showing that original user or any others another recommendation, so eventually you could end up with a system that always displays the same options to all users due to its own feedback loop; and it also has no chance to discover by chance any other correlations.</br>
Whereas if a system occasionally shows a recommendation of which does not fit any current trends, but that options now gets clicks under a pattern that previously would have gone undiscovered</p><a name="Foundational Knowledge" class="target" href="#Foundational Knowledge" style="text-decoration:none;"><h2>Foundational Knowledge</h2></a><blockquote><p>Presume that <code inline="true">rand()</code> produces random a number <code inline="true">0 < x < 1</code>
</p></blockquote><p>
The simplest generation of a random value would be the use of;
<code><span class="typ">let</span>&nbspy&nbsp<span class="kwd">=</span>&nbsp<span class="cal">rand</span>();</code>
If we instead replace <code inline="true">rand()</code> with <code inline="true">x</code> you can see how this is a simple <code inline="true">1:1</code> relationship. However, if we instead use a more complex geometric relationship like <code inline="true">y=x^2</code>, we can see how the average <code inline="true">y</code> value between <code inline="true">0 < x < 1</code> is less than <code inline="true">0.5</code>. Thus when we use that relationship to generate a random number it is more likely to get a number below <code inline="true">0.5</code> than above it.
<code><span class="typ">let</span>&nbspy&nbsp<span class="kwd">=</span>&nbsp<span class="cal">rand</span>()<span class="kwd">*</span><span class="kwd">*</span><span class="lit">2</span>;</code></p><a name="Custom Functions" class="target" href="#Custom Functions" style="text-decoration:none;"><h3>Custom Functions</h3></a><p>
If you are randomly picking between an apple and a banana there is a 50-50 chance of either being selected; however, if you want the apple to have double the chance of being selected then you would pick from <code inline="true">[apple, apple, bannana]</code>.</br>
While this works as a basic implementation it does not create a range of variety and customisation for how to weight each object, what if you want a 13-87 chance between apple and banana? Are you really going to create a list of 100 items then randomly select an item?</br>
The whole process can be simplified.</p><a name="Custom Weighted Randoms" class="target" href="#Custom Weighted Randoms" style="text-decoration:none;"><h2>Custom Weighted Randoms</h2></a><p>
Using the previous examples we can say;
<code type="eq"><span class="row"><span class="variable">Apple</span><span class="opper">=</span><span class="variable">2</span></span><span class="row"><span class="variable">Banana</span><span class="opper">=</span><span class="variable">1</span></span><span class="row"><span class="variable">Total</span><span class="opper">=</span><span class="variable">3</span></span></code>
So now we can simply stretch our random function to fit over the domain of our options;
<code>y&nbsp<span class="kwd">=</span>&nbsp<span class="cal">rand</span>()&nbsp<span class="kwd">*</span>&nbsp3</code>
Then simply deduce that if <code inline="true">y</code> is <code inline="true">< 2</code> it must be an apple and otherwise it is a banana.</p><a name="Generalisation" class="target" href="#Generalisation" style="text-decoration:none;"><h3>Generalisation</h3></a><p>
We can now expand on this to make a general algorithm.</br>
Assume that the system is given the weights of each option and the options its self.
<code><span class="typ">let</span>&nbspweights&nbsp<span class="kwd">=</span>&nbsp[...];<br><span class="typ">let</span>&nbspopts&nbsp<span class="kwd">=</span>&nbsp[...]</code>
First, we tally up the total weight
<code><span class="typ">let</span>&nbsptotal&nbsp<span class="kwd">=</span>&nbsp<span class="lit">0</span>;<br><span class="kwd">for</span>&nbsp(<span class="typ">let</span>&nbspweight&nbsp<span class="kwd">of</span>&nbspweights){<br>&nbsp&nbsptotal&nbsp<span class="kwd">+</span><span class="kwd">=</span>&nbspweight;<br>}</code>
Apply are random function to the domain
<code><span class="typ">let</span>&nbspy&nbsp<span class="kwd">=</span>&nbsp<span class="cal">rand</span>()&nbsp<span class="kwd">*</span>&nbsptotal;</code>
Now deduce which option the result belongs to.
<code><span class="kwd">for</span>&nbsp(<span class="typ">let</span>&nbspindex&nbsp<span class="kwd">in</span>&nbspweights){<br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(y&nbsp<span class="kwd">&lt</span>&nbspweights[index]){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspopt[index];<br>&nbsp&nbsp}<br><br>&nbsp&nbspy&nbsp<span class="kwd">-</span><span class="kwd">=</span>&nbspweights[index];<br>}</code></p><a name="Back to Numeric" class="target" href="#Back to Numeric" style="text-decoration:none;"><h3>Back to Numeric</h3></a><p>
While it's great to be able to have a weighted random system that picks specific options, if you want actual numeric values then it will be more complex.</br>
First, you need to ensure that your <code inline="true">weights opts</code> pairs are sorted by <code inline="true">opt</code> value.</br>
Then we can use a basic interpolation operation.</br>
This method will allow you to weight specific numbers within the system and the range of output is defined by the lowest and highest option available.
<code><span class="kwd">for</span>&nbsp(<span class="typ">let</span>&nbspindex&nbsp<span class="kwd">in</span>&nbspweights){<br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(y&nbsp<span class="kwd">&lt</span>&nbspweights[index]){<br>&nbsp&nbsp&nbsp&nbsp<span class="com">//&nbspIf&nbspit&nbspis&nbspthe&nbsplast&nbspoption</span><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(index&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbspopts.length&nbsp<span class="kwd">-</span><span class="lit">1</span>){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspopts[index];<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="typ">let</span>&nbspp&nbsp<span class="kwd">=</span>&nbspy&nbsp<span class="kwd">/&nbsp</span>weights[index];<br>&nbsp&nbsp&nbsp&nbsp<span class="typ">let</span>&nbspval&nbsp<span class="kwd">=</span>&nbsp(opts[index<span class="kwd">+</span><span class="lit">1</span>]&nbsp<span class="kwd">-</span>&nbspopts[index])&nbsp<span class="kwd">*</span>&nbspp&nbsp<span class="kwd">+</span>&nbspopts[index];<br><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspval;<br>&nbsp&nbsp}<br><br>&nbsp&nbspy&nbsp<span class="kwd">-</span><span class="kwd">=</span>&nbspweights[index];<br>}</code></p><span class="tags"><h6 style="display: inline-block;">Tags:</h6><a href="/t/IPT.html"><tag>IPT;</tag></a></span></div><footer>
	<a href="https://goo.gl/forms/8wgwU9mPZlKogDEn2">Feedback</a>
	<a href="/feed.rss" style="float:right">RSS Feed</a>
</footer></body>
<head><title>Case Study: Guess Who</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#d81b60">

<link rel="stylesheet" type="text/css" href="/style/main.css">
<link rel="stylesheet" type="text/css" href="/style/head.css">
<link rel="stylesheet" type="text/css" href="/style/footer.css">
<link rel="stylesheet" type="text/css" href="/style/article.css">
<link rel="stylesheet" type="text/css" href="/style/snippet.css"></head><body><header>
	<a href="/index.html">Home</a>
	<a href="/feed.html">Feed</a>
	<a href="/p/me.html" style="float: right;">Ajani James Bilby</a>
</header><div class="wrapper"><h1>Case Study: Guess Who</h1><blockquote><p>Code related to this article can be found <a href="https://github.com/Hobgoblin101/Hobgoblin101.github.io/tree/master/code/7">here</a>.
</p></blockquote><p>
To implement an online guess who app capable of having millions of popular people listed in it is a large data problem.</br>
We also need to be able to add more people to our system as time goes on, so it doesn't become outdated, and we need it to be fast and scalable to allow many people to use our app at the same time.</br></p><p>
There are countless solutions to this task, and the one I will be covering uses relational table databases.</br>
Table databases are proven solution to storing large amounts of interlinking data efficiently, and over many years it has been refined to be highly efficient and scalable.</p><break></break><a name="Data-Structure" class="target" href="#Data-Structure" style="text-decoration:none;"><h2>Data-Structure</h2></a><p>
We need to work out how to break now all the linking information that exists in this problem and turn them into restricted field linear data.</br>
First we can think of breaking down the problem into rules (questions) and people.</p><a name="tblQuestions" class="target" href="#tblQuestions" style="text-decoration:none;"><h3>tblQuestions</h3></a><p><table><tr><th>Field </th><th>Type </th><th>Description </th></tr><tr><td style="text-align:left;">name </td><td style="text-align:center;">String(25) </td><td style="text-align:left;">The name of the person</td></tr></table></p><a name="tblPeople" class="target" href="#tblPeople" style="text-decoration:none;"><h3>tblPeople</h3></a><p><table><tr><th>Field </th><th>Type </th><th>Description </th></tr><tr><td style="text-align:left;">prompt </td><td style="text-align:center;">String(45) </td><td style="text-align:left;">The actual question</td></tr></table></p><blockquote><p>It is important to remember that we are only storing facts about people, not what isn't a fact (i.e. "they don't have brown hair")
</p></blockquote><a name="tblMatch" class="target" href="#tblMatch" style="text-decoration:none;"><h3>tblMatch</h3></a><p><table><tr><th>Field </th><th>Type </th><th>Description </th></tr><tr><td style="text-align:left;">person </td><td style="text-align:center;">uint </td><td style="text-align:left;">Index reference of the referred person</td></tr><tr><td style="text-align:left;">question </td><td style="text-align:center;">uint </td><td style="text-align:left;">Index reference of the referred person</td></tr></table></p><break></break><a name="Interfacing" class="target" href="#Interfacing" style="text-decoration:none;"><h2>Interfacing</h2></a><p>
Now that we know how to store our data we need to think about how we can pick a person out of this database as a result, as well as what questions to prompt the user with to find out who their person is.</br></p><p>
If we break out into a little thought experiment and presumed that for every 10,000 people one person was in our system. We'll say on average every person has at least 30 rules linked to them. Therefor the size of our matching table would be;
<code type="eq"><span class="row"><span class="fract" w="f"><sup><span class="char">7</span><span class="opper">×</span><span class="pow"><span class="base"><span class="char">1</span><span class="char">0</span></span><sup><span class="char">1</span><span class="char">2</span></sup></span></sup><sub><span class="char">1</span><span class="char">0</span><span class="char">0</span><span class="char">0</span><span class="char">0</span></sub></span><span class="opper">×</span><span class="char">8</span><span class="opper">×</span><span class="char">2</span><span class="opper">≈</span><span class="char">1</span><span class="char">0</span><span class="char">G</span><span class="char">B</span></span><span class="row"></span></code>
So we can see that we can't keep a working copy of possible matches for each game, even if with each question the number of possible people halved it would still be impractical to keep any of it in ram.</br>
We need to calculate everything on each request then dump all of the working data.</p><p>
So we need to have the client remember what questions they have asked and each type them answser a question they send that result as well as all previous results as part of one request.</p><break></break><a name="Matching people" class="target" href="#Matching people" style="text-decoration:none;"><h2>Matching people</h2></a><p>
To select the most appropriate question we need to know what people apply to the current rule set, so we can work out which question will best divide the options available. Thus, matching people with the currently know rules isn't just an end game state, but also a recurring feature.</p><p>
A way of doing this is looping though every single tuple in the matching table then removing any matches that include people that don't follow the rules.</br>
To save on read cycles we can do this in once parse of the table.</br>
We read the table tuple by tuple finding if the current tuple relates to any of the known rules, as we go we add people to a list as well as what questions apply to them.</br></p><p>
If we find any tuple of which links to a question that was marked as wrong by the user, we can remove that person from our cache as then add them to a black-list, so we don't re-add them.</br>
<code><span class="typ">let</span>&nbsppeople&nbsp<span class="kwd">=</span>&nbsp{};<br><span class="typ">let</span>&nbspblackList&nbsp<span class="kwd">=</span>&nbsp{};<br><br>scan:&nbsp<span class="kwd">for</span>&nbsp(tuple&nbsp<span class="kwd">of</span>&nbsptblMatch){<br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(tuple.person&nbsp<span class="kwd">in</span>&nbspblackList){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">continue</span>&nbspscan;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(tuple.question&nbsp<span class="kwd">in</span>&nbsprules&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbsprule.value&nbsp<span class="kwd">=</span><span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="lit">false</span>){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">delete</span>&nbsppeople[tuple.person];<br>&nbsp&nbsp&nbsp&nbspblackList.<span class="cal">push</span>(tuple.person);<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">continue</span>&nbspscan;<br>&nbsp&nbsp}<br><br>&nbsp&nbsppeople[tuple.person].<span class="cal">push</span>(tuple.question);<br>}</code></p><p>
However, this does nothing for any rules that are true, however for rules that are true they only need to exist once per person, thus we need to of scaned the entire list to see if there are any links between each person and the rule that is rule. We have just created this list <code inline="true">people</code>.</br>
Now we can run though that and apply the rules of which their value was <code inline="true">true</code>.
<code>outer:&nbsp<span class="kwd">for</span>&nbsp(person&nbsp<span class="kwd">in</span>&nbsppeople){<br>&nbsp&nbspinner:&nbsp<span class="kwd">for</span>&nbsp(rule&nbsp<span class="kwd">of</span>&nbsprules){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(rule&nbsp<span class="kwd">not</span>&nbsp<span class="kwd">in</span>&nbspperson){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="kwd">delete</span>&nbspperson;<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="kwd">continue</span>&nbspouter;<br>&nbsp&nbsp&nbsp&nbsp}<br>&nbsp&nbsp}<br>}</code></p><break></break><a name="Finding Appropriate Questions" class="target" href="#Finding Appropriate Questions" style="text-decoration:none;"><h2>Finding Appropriate Questions</h2></a><p>
Now that we have a list of links for people that apply to all the current rules we can choose an appropriate question.</p><p>
The best possible question to ask is one that evenly divides the remaining options, because no matter the choice you will remove a considerable amout of possibilites.</br></p><p>
To do this we need to loop though our results and count how many times each question occurs.
<code><span class="typ">let</span>&nbspcount&nbsp<span class="kwd">=</span>&nbsp[];<br><br>outer:&nbsp<span class="kwd">for</span>&nbsp(<span class="typ">let</span>&nbspperson&nbsp<span class="kwd">of</span>&nbsppeople){<br>&nbsp&nbspinner:&nbsp<span class="kwd">for</span>&nbsp(<span class="typ">let</span>&nbsprule&nbsp<span class="kwd">of</span>&nbspperson){<br>&nbsp&nbsp&nbsp&nbspcount[rule].num&nbsp<span class="kwd">+</span><span class="kwd">=</span>&nbsp<span class="lit">1</span>;<br>&nbsp&nbsp}<br>}</code></p><p>
Now we need to find the dividing factor, this will be;
<code type="eq"><span class="row"><span class="char">h</span><span class="char">a</span><span class="char">v</span><span class="char">e</span><span class="char">n</span><span class="char">o</span><span class="char">t</span><span class="opper">-</span><span class="char">h</span><span class="char">a</span><span class="char">v</span><span class="char">e</span></span><span class="row"></span></code>
<code>num&nbsp<span class="kwd">=</span>&nbsppeople.length;&nbsp<span class="com">//&nbspNumber&nbspof&nbsppeople</span><br><br><span class="kwd">for</span>&nbsp(<span class="typ">let</span>&nbspopt&nbsp<span class="kwd">in</span>&nbspcount){<br>&nbsp&nbsp<span class="typ">let</span>&nbspno&nbsp<span class="kwd">=</span>&nbspnum&nbsp<span class="kwd">-</span>&nbspcount[rule].num;<br>&nbsp&nbsp<span class="typ">let</span>&nbspyes&nbsp<span class="kwd">=</span>&nbspcount[rule].num;<br><br>&nbsp&nbspopt.val&nbsp<span class="kwd">=</span>&nbspMath.<span class="cal">abs</span>(&nbspno&nbsp<span class="kwd">-</span>&nbspyes&nbsp)<br>}</code></p><p>
Now we know what the next best question is because we can just see which value the highest value as ask that.</p><blockquote><p>It is important to remember that this system does not have any system to stop it from asking repeated questions.
</p></blockquote><break></break><a name="Summary" class="target" href="#Summary" style="text-decoration:none;"><h2>Summary</h2></a><p>
It is important to remember that for the first couple of questions the system will still require storing a large percent of the table in ram for processing.</br>
If every question halved the number of possible results, then percent stored in ram would be;
<code type="eq"><span class="row"><span class="pow"><span class="base"><span class="char">0</span><span class="char">.</span><span class="char">5</span></span><sup><span class="char">n</span></sup></span></span><span class="row"></span></code></p><p>
So after three questions of our previous example the ram used would be
<code type="eq"><span class="row"><span class="pow"><span class="base"><span class="char">0</span><span class="char">.</span><span class="char">5</span></span><sup><span class="char">3</span></sup></span><span class="opper">×</span><span class="char">1</span><span class="char">0</span><span class="char">G</span><span class="char">B</span><span class="opper">=</span><span class="char">1</span><span class="char">.</span><span class="char">2</span><span class="char">5</span><span class="char">G</span><span class="char">B</span></span><span class="row"></span></code></p><p>
It also means that by that rule to find one person it would require
<code type="eq"><span class="row"><span class="fract" w="f"><sup><span class="char">7</span><span class="opper">×</span><span class="pow"><span class="base"><span class="char">1</span><span class="char">0</span></span><sup><span class="char">9</span></sup></span></sup><sub><span class="char">1</span><span class="char">0</span><span class="char">0</span><span class="char">0</span><span class="char">0</span></sub></span><span class="opper">×</span><span class="pow"><span class="base"><span class="char">0</span><span class="char">.</span><span class="char">5</span></span><sup><span class="char">n</span></sup></span><span class="opper">=</span><span class="char">1</span></span><span class="row"><span class="pow"><span class="base"><span class="char">0</span><span class="char">.</span><span class="char">5</span></span><sup><span class="char">n</span></sup></span><span class="opper">=</span><span class="fract" w="f"><sup><span class="char">1</span></sup><sub><span class="char">7</span><span class="opper">×</span><span class="pow"><span class="base"><span class="char">1</span><span class="char">0</span></span><sup><span class="char">8</span></sup></span></sub></span></span><span class="row"><span class="char">n</span><span class="opper">=</span><span class="fract" w="f"><sup><span class="char">l</span><span class="char">o</span><span class="char">g</span>(1.42 * (10) ^ (-9))</sup><sub><span class="char">l</span><span class="char">o</span><span class="char">g</span>(0.5)</sub></span></span><span class="row"><span class="char">n</span><span class="opper">≈</span><span class="char">3</span><span class="char">0</span></span><span class="row"></span></code></p><p>
Which would be extremely boring as a player, also it would require a lot of admin to have that many people in the DBMS. Thus, realistically the system would be a lot smaller in scale.</br>
However, it is still a good idea to cache the first couple of possible questions as a tree so that they don't need to be recalculated for each user, and instead they only run operations of which will initially eliminate  a lot more results than the first questions would.</p><span class="tags"><h6 style="display: inline-block;">Tags:</h6><a href="/t/IPT.html"><tag>IPT;</tag></a><a href="/t/Case-Study.html"><tag>Case-Study;</tag></a></span></article></div><footer>
	<a href="https://goo.gl/forms/8wgwU9mPZlKogDEn2">Feedback</a>
	<a href="/feed.rss" style="float:right">RSS Feed</a>
</footer></body>
<head><title>Key VS Value Hashing</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#24292e">

<link rel="stylesheet" type="text/css" href="/style/main.css">
<link rel="stylesheet" type="text/css" href="/style/head.css">
<link rel="stylesheet" type="text/css" href="/style/footer.css">
<link rel="stylesheet" type="text/css" href="/style/article.css">
<link rel="stylesheet" type="text/css" href="/style/snippet.css"></head><body><header>
  <a href="/index.html">Home</a>
  <a href="/p/me.html" style="float: right;">Ajani James Bilby</a>
</header><div class="wrapper"><h1>Key VS Value Hashing</h1><p>Both Key and Value hashing aim to convert strings or any other data into a unique number. However, both do it in different ways to be optimal for their purposes.</p><a name="Value / Data hashing"><h2>Value / Data hashing</h2></a><p>
Aims to encrypt data so it is a completely unique number of which is relatively impossible to work backwards (number to string). And there should be no encoding collisions.</br>
Since these hashes are normally stored, the length of them is not to much of an issue.</p><break></break><a name="Key Hashing"><h2>Key Hashing</h2></a><p>
Allows objects to be stored as an array.</br>
Say that you have a DNS object <code inline="true">{'google.com': '8.8.8.8', 'facebook.com': '31.13.95.36'}</code>.</br>
If you have a ton of domain names, then to find the specific IP of a server requires you to scan all of the keys to find the correct one then return it's result.</br>
Thus, the larger that your table gets, your request will increase in time exponentially.</br></p><p>
Thus, they encode the Key value into a number, then store it as an array.</br>
There for when you are trying to find <code inline="true">google.com</code>'s IP, you just re-encode the string, then you know the exact index of the result.</br>
No lookup time required.</br></p><p>
A way on encoding that would be to literally convert it to a number.<table><tr><th></th><th></th></tr><tr><td style="text-align:right;">Hex</td><td style="text-align:left;"><code inline="true">67 6f 6f 67 6c 65 2e 63 6f 6d</code> </td></tr><tr><td style="text-align:right;">Decimal</td><td style="text-align:left;"><code inline="true">5.1679268198614805e+23</code> </td></tr></table></p><p>
Of which as you can tell is longer than the longest possible integer, thus we would have a problem indexing it.</br>
So, we can try and restricting the character spacing and making our own string to number algorithm .
<code><span class="typ">let&nbsp</span>chars&nbsp<span class="kwd">=</span>&nbsp'abcdefghijklmnopqrstuvwxyz-_.';<br><br><span class="typ">function&nbsp</span>encode(str){<br>&nbsp&nbsp<span class="typ">let&nbsp</span>res&nbsp<span class="kwd">=</span>&nbsp<span class="lit">0</span>;<br><br>&nbsp&nbsp<span class="kwd">for</span>&nbsp(<span class="typ">let&nbsp</span>i<span class="kwd">=</span><span class="lit">0</span>;&nbspi<span class="kwd">&lt</span>str.length;&nbspi<span class="kwd">+</span><span class="kwd">+</span>){<br>&nbsp&nbsp&nbsp&nbsp<span class="typ">let&nbsp</span>j<span class="kwd">=</span>chars.indexOf(str[i]);<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(j&nbsp<span class="kwd">=</span><span class="kwd">=</span><span class="kwd">=</span>&nbsp-<span class="lit">1</span>){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspthrow&nbspError('Invalid&nbspcharacter:',&nbspstr[i]);<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="typ">let&nbsp</span>exp&nbsp<span class="kwd">=</span>&nbspMath.pow(chars.length,&nbspi);<br><br>&nbsp&nbsp&nbsp&nbspres&nbsp<span class="kwd">+</span><span class="kwd">=</span>&nbspj&nbsp<span class="kwd">*</span>&nbspexp;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="kwd">return&nbsp</span>res;<br>}<br><br>encode('google.com');&nbsp<span class="com">//returns&nbsp181140446280695</span></code>
This is a better value since we can actually index it, and as long as the string isn't just made up of <code inline="true">a</code>s it will be fine (it would be like having a number which is just a bunch of zeros). Also, any trailing <code inline="true">a</code>s will not be accounted for since this is a little endian encoding, and it would be like having a bunch of zeros in front of your number. This could be fixed by adding <code inline="true">1</code> to <code inline="true">j</code>. But this isn't the point.</br></p><break></break><p>
To store <code inline="true">google.com</code> we need to have at least <code inline="true">181140446280695</code> blank items before this one, or else the index wouldn't actually match.</br>
Thus, we are not getting into the realm of intentional hashing collisions.</br></p><p>
Within this algorithm (excluding the <code inline="true">a</code> problem) there will be no two strings that make the same result, thus you will never have any conflicting pointers (having two sites attempting to use the same index).</br>
However, we can case match out algorithm to better fit our problem.</br></p><break></break><p>
If we were storing an address book, our key values would only include valid names.</br>
Thus, we would not need to be concerned with the fact that <code inline="true">aaa</code>, and <code inline="true">baaaa</code> may have the same index.</br>
As those two keys will never actually occur without system.</br></p><p>
So now we can realize that we only need to care about valid data.</p><blockquote><p>This does leave problems for intentionally malicious users to intentionally make conflicts within the system, thus destroying data
</p></blockquote><p><code><span class="typ">let&nbsp</span>chars&nbsp<span class="kwd">=</span>&nbsp'abcdefghijklmnopqrstuvwxyz';<br><br><span class="typ">function&nbsp</span>encode(str){<br>&nbsp&nbspstr&nbsp<span class="kwd">=</span>&nbspstr.toLowerCase();<br>&nbsp&nbsp<span class="typ">let&nbsp</span>res&nbsp<span class="kwd">=</span>&nbspchars.indexOf(str[<span class="lit">0</span>])<span class="kwd">+</span><span class="lit">1</span>;<br><br>&nbsp&nbsp<span class="kwd">for</span>&nbsp(<span class="typ">let&nbsp</span>i<span class="kwd">=</span><span class="lit">1</span>;&nbspi<span class="kwd">&lt</span>str.length;&nbspi<span class="kwd">+</span><span class="kwd">+</span>){<br>&nbsp&nbsp&nbsp&nbspres&nbsp<span class="kwd">*</span><span class="kwd">=</span>&nbspchars.indexOf(str[i])<span class="kwd">+</span><span class="lit">1</span>;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="kwd">return&nbsp</span>res;<br>}<br><br><span class="com">//&nbspTest&nbspa&nbspfew&nbspnames</span><br><span class="typ">let&nbsp</span>names&nbsp<span class="kwd">=</span>&nbsp['Alex',&nbsp'Anthony',&nbsp'Carla',&nbsp'Casandra',&nbsp'Jaxon',&nbsp'Jackson',&nbsp'Jack',&nbsp'Jimmy',&nbsp'Jim',&nbsp'John'];<br><span class="kwd">for</span>&nbsp(<span class="typ">let&nbsp</span>name<span class="kwd">&nbspof&nbsp</span>names){<br>&nbsp&nbspconsole.log(name,&nbspencode(name));<br>}</code></p><p><table><tr><th>Name </th><th>Decimal </th></tr><tr><td style="text-align:right;">Alex</td><td style="text-align:left;">1440</td></tr><tr><td style="text-align:right;">Anthony</td><td style="text-align:left;">11760000</td></tr><tr><td style="text-align:right;">Carla</td><td style="text-align:left;">648</td></tr><tr><td style="text-align:right;">Casandra</td><td style="text-align:left;">57456</td></tr><tr><td style="text-align:right;">Jaxon</td><td style="text-align:left;">50400</td></tr><tr><td style="text-align:right;">Jackson</td><td style="text-align:left;">1316700</td></tr><tr><td style="text-align:right;">Jack</td><td style="text-align:left;">330</td></tr><tr><td style="text-align:right;">Jimmy</td><td style="text-align:left;">380250</td></tr><tr><td style="text-align:right;">Jim</td><td style="text-align:left;">1170</td></tr><tr><td style="text-align:right;">John</td><td style="text-align:left;">16800</td></tr></table></p><p>
As you can see we have no conflicts without sample data, and our biggest value is only <code inline="true">11760000</code>.</br>
Thus, that is the length of our array to store these people efficiently.</p><break></break><p>
We can also push out system to the extreme, getting a <a href="https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt">list of words</a> and testing for conflicts.</br>
After executing it (<a href="/code/4-1.js">code</a>) we get the results;
<code><span class="lit">2</span><span class="lit">9</span><span class="lit">3</span><span class="lit">5</span><span class="lit">5</span><span class="lit">5</span>&nbspcollided<span class="kwd">&nbspof&nbsp</span><span class="lit">3</span><span class="lit">7</span><span class="lit">0</span><span class="lit">0</span><span class="lit">9</span><span class="lit">3</span><br>&nbsp&nbsp<span class="lit">7</span><span class="lit">9</span>.<span class="lit">3</span><span class="lit">1</span><span class="lit">9</span><span class="lit">2</span><span class="lit">5</span><span class="lit">2</span><span class="lit">1</span><span class="lit">8</span><span class="lit">7</span><span class="lit">9</span><span class="lit">6</span><span class="lit">3</span><span class="lit">5</span><span class="lit">6</span><span class="kwd">%</span>&nbsp</code>
Which for our little algorithm  whipped up in a couple of minutes isn't too bad, especially since the algorithm is for names and less that 30% of the words in the list are names, we can say it was almost successful, but heavlily not recommend for real world situations.</br>
We can also conclude that it only made <code inline="true">76538</code> unique numbers, of which is actually very bad for our use case since the largest result index was <code inline="true">6.868313676231082e+30</code>.</br>
However, it is still important to remember that this is still a much better result that our first hashing algorithm of which couldn't even index an eight-character string let alone a 10.</br>
Also, our first algorithm given the same problem has only <code inline="true">1.176%</code> collision rate, but we cannot actually store any reasonable size strings.</p><break></break><p>
All in all, you can see why it is valuable to have specific case-based hashing functions.</br>
Possible solutions to some of the problems we have seen is using hashing to predict the location, but also storing the key along with the data, thus if a collision occurs the new value can be stored in the next empty index, of which can then be searched for when the predicted location does not match. Thus, you can get the speed ups of hashing while still storing a large variety of key values.</br></p><p>
Another possible solution which can cause unpredictable results, is training a recursive neural network of example keys to generate values that do not conflict with one another, but still use the smallest amout of indexes possible. This effectively is like free loading of a general solution of which may not always work and will increase initial index prediction processing.</p><break></break><a name="Related"><h2>Related</h2></a><p><ul><li><a href="/p/5.html">Appendix: Key VS Value Hashing</a></li></ul></p><break></break><a name="References"><h2>References</h2></a><p><ol><li>James Curran (NCSS)</li></ol></p><span class="tags"><h6 style="display: inline-block;">Tags:</h6><a href="/t/IPT.html"><tag>IPT;</tag></a></span></article></div><footer>
  <a href="https://goo.gl/forms/8wgwU9mPZlKogDEn2">Feedback</a>
  <a href="/feed.rss" style="float:right">RSS Feed</a>
</footer></body>
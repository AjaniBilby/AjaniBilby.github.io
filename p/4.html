<head><title>Key VS Value Hashing</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#d81b60">

<link rel="stylesheet" type="text/css" href="/style/main.css">
<link rel="stylesheet" type="text/css" href="/style/head.css">
<link rel="stylesheet" type="text/css" href="/style/footer.css">
<link rel="stylesheet" type="text/css" href="/style/article.css">
<link rel="stylesheet" type="text/css" href="/style/snippet.css"></head><body><header>
	<a href="/index.html" style="float: left;">Home</a>
	<a href="/feed.html" style="float: left;">Feed</a>
	<a href="/p/me.html" style="float: right;">Ajani James Bilby</a>
</header><div class="wrapper"><h1>Key VS Value Hashing</h1><p>Both Key and Value hashing aim to convert strings or any other data into a unique number. However, both do it in different ways to be optimal for their purposes.</p><a name="Value / Data hashing" class="target" href="#Value / Data hashing" style="text-decoration:none;"><h2>Value / Data hashing</h2></a><p>
Aims to encrypt data so it is a completely unique number of which is relatively impossible to work backwards (number to string). And there should be no encoding collisions.</br>
Since these hashes are normally stored, the length of them is not too much of an issue.</p><break></break><a name="Key Hashing" class="target" href="#Key Hashing" style="text-decoration:none;"><h2>Key Hashing</h2></a><p>
Allows objects to be stored as an array.</br>
Say that you have a DNS object <code inline="true">{'google.com': '8.8.8.8', 'facebook.com': '31.13.95.36'}</code>.</br>
If you have a ton of domain names, then to find the specific IP of a server requires you to scan all of the keys to find the correct one then return its result.</br>
Thus, the larger than your table gets, your request will increase in time exponentially.</br></p><p>
Thus, they encode the Key value into a number, then store it as an array.</br>
Therefor when you are trying to find <code inline="true">google.com</code>'s IP, you just re-encode the string, then you know the exact index of the result.</br>
No lookup time required.</br></p><p>
A method on encoding that would be to literally convert it to a number.<table><tr><th></th><th></th></tr><tr><td style="text-align:right;">Hex</td><td style="text-align:left;"><code inline="true">67 6f 6f 67 6c 65 2e 63 6f 6d</code> </td></tr><tr><td style="text-align:right;">Decimal</td><td style="text-align:left;"><code inline="true">5.1679268198614805e+23</code> </td></tr></table></p><p>
Of which as you can tell is longer than the longest possible integer, thus we would have a problem indexing it.</br>
So, we can try and restricting the character spacing and making our own string to number algorithm.
<code><span class="typ">let</span>&nbspchars&nbsp<span class="kwd">=</span>&nbsp<span class="str">'abcdefghijklmnopqrstuvwxyz-_.'</span>;<br><br>function&nbsp<span class="cal">encode</span>(str){<br>&nbsp&nbsp<span class="typ">let</span>&nbspres&nbsp<span class="kwd">=</span>&nbsp<span class="lit">0</span>;<br><br>&nbsp&nbsp<span class="kwd">for</span>&nbsp(<span class="typ">let</span>&nbspi<span class="kwd">=</span><span class="lit">0</span>;&nbspi<span class="kwd">&lt</span>str.length;&nbspi<span class="kwd">+</span><span class="kwd">+</span>){<br>&nbsp&nbsp&nbsp&nbsp<span class="typ">let</span>&nbspj<span class="kwd">=</span>chars.<span class="cal">indexOf</span>(str[i]);<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(j&nbsp<span class="kwd">=</span><span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="kwd">-</span><span class="lit">1</span>){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="kwd">throw</span>&nbsp<span class="cal">Error</span>(<span class="str">'Invalid&nbspcharacter:'</span>,&nbspstr[i]);<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="typ">let</span>&nbspexp&nbsp<span class="kwd">=</span>&nbspMath.pow(chars.length,&nbspi);<br><br>&nbsp&nbsp&nbsp&nbspres&nbsp<span class="kwd">+</span><span class="kwd">=</span>&nbspj&nbsp<span class="kwd">*</span>&nbspexp;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="kwd">return</span>&nbspres;<br>}<br><br><span class="cal">encode</span>(<span class="str">'google.com'</span>);&nbsp<span class="com">//returns&nbsp181140446280695</span></code>
This is a better value since we can actually index it, and as long as the string isn't just made up of <code inline="true">a</code>s it will be fine (it would be like having a number which is just a bunch of zeros). Also, any trailing <code inline="true">a</code>s will not be accounted for since this is a little endian encoding, and it would be like having a bunch of zeros in front of your number. This could be fixed by adding <code inline="true">1</code> to <code inline="true">j</code>. But this isn't the point.</br></p><break></break><p>
To store <code inline="true">google.com</code> we need to have at least <code inline="true">181140446280695</code> blank items before this one, or else the index wouldn't actually match.</br>
Thus, we are not getting into the realm of intentional hashing collisions.</br></p><p>
Within this algorithm (excluding the <code inline="true">a</code> problem) there will be no two strings that make the same result, thus you will never have any conflicting pointers (having two sites attempting to use the same index).</br>
However, we can case match out an algorithm to better fit our problem.</br></p><break></break><p>
If we were storing an address book, our key values would only include valid names.</br>
Thus, we would not need to be concerned with the fact that <code inline="true">aaa</code>, and <code inline="true">baaaa</code> may have the same index.</br>
As those two keys will never actually occur within the system.</br></p><p>
So now we can realize that we only need to care about valid data.</p><blockquote><p>This does leave problems for intentionally malicious users to intentionally make conflicts within the system, thus destroying data
</p></blockquote><p><code><span class="typ">let</span>&nbspchars&nbsp<span class="kwd">=</span>&nbsp<span class="str">'abcdefghijklmnopqrstuvwxyz'</span>;<br><br>function&nbsp<span class="cal">encode</span>(str){<br>&nbsp&nbspstr&nbsp<span class="kwd">=</span>&nbspstr.toLow<span class="cal">erCase</span>();<br>&nbsp&nbsp<span class="typ">let</span>&nbspres&nbsp<span class="kwd">=</span>&nbspchars.<span class="cal">indexOf</span>(str[<span class="lit">0</span>])<span class="kwd">+</span><span class="lit">1</span>;<br><br>&nbsp&nbsp<span class="kwd">for</span>&nbsp(<span class="typ">let</span>&nbspi<span class="kwd">=</span><span class="lit">1</span>;&nbspi<span class="kwd">&lt</span>str.length;&nbspi<span class="kwd">+</span><span class="kwd">+</span>){<br>&nbsp&nbsp&nbsp&nbspres&nbsp<span class="kwd">*</span><span class="kwd">=</span>&nbspchars.<span class="cal">indexOf</span>(str[i])<span class="kwd">+</span><span class="lit">1</span>;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="kwd">return</span>&nbspres;<br>}<br><br><span class="com">//&nbspTest&nbspa&nbspfew&nbspnames</span><br><span class="typ">let</span>&nbspnames&nbsp<span class="kwd">=</span>&nbsp[<span class="str">'Alex'</span>,&nbsp<span class="str">'Anthony'</span>,&nbsp<span class="str">'Carla'</span>,&nbsp<span class="str">'Casandra'</span>,&nbsp<span class="str">'Jaxon'</span>,&nbsp<span class="str">'Jackson'</span>,&nbsp<span class="str">'Jack'</span>,&nbsp<span class="str">'Jimmy'</span>,&nbsp<span class="str">'Jim'</span>,&nbsp<span class="str">'John'</span>];<br><span class="kwd">for</span>&nbsp(<span class="typ">let</span>&nbspname&nbsp<span class="kwd">of</span>&nbspnames){<br>&nbsp&nbspconsole.<span class="cal">log</span>(name,&nbsp<span class="cal">encode</span>(name));<br>}</code></p><p><table><tr><th>Name </th><th>Decimal </th></tr><tr><td style="text-align:right;">Alex</td><td style="text-align:left;">1440</td></tr><tr><td style="text-align:right;">Anthony</td><td style="text-align:left;">11760000</td></tr><tr><td style="text-align:right;">Carla</td><td style="text-align:left;">648</td></tr><tr><td style="text-align:right;">Casandra</td><td style="text-align:left;">57456</td></tr><tr><td style="text-align:right;">Jaxon</td><td style="text-align:left;">50400</td></tr><tr><td style="text-align:right;">Jackson</td><td style="text-align:left;">1316700</td></tr><tr><td style="text-align:right;">Jack</td><td style="text-align:left;">330</td></tr><tr><td style="text-align:right;">Jimmy</td><td style="text-align:left;">380250</td></tr><tr><td style="text-align:right;">Jim</td><td style="text-align:left;">1170</td></tr><tr><td style="text-align:right;">John</td><td style="text-align:left;">16800</td></tr></table></p><p>
As you can see we have no conflicts without sample data, and our biggest value is only <code inline="true">11760000</code>.</br>
Thus, that is the length of our array to store these people efficiently.</p><break></break><p>
We can also push our system to the extreme, getting a <a href="https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt">list of words</a> and testing for conflicts.</br>
After executing it (<a href="/code/4-1.js">code</a>) we get the results;
<code><span class="lit">2</span><span class="lit">9</span><span class="lit">3</span><span class="lit">5</span><span class="lit">5</span><span class="lit">5</span>&nbspcollided&nbsp<span class="kwd">of</span>&nbsp<span class="lit">3</span><span class="lit">7</span><span class="lit">0</span><span class="lit">0</span><span class="lit">9</span><span class="lit">3</span><br>&nbsp&nbsp<span class="lit">7</span><span class="lit">9</span>.<span class="lit">3</span><span class="lit">1</span><span class="lit">9</span><span class="lit">2</span><span class="lit">5</span><span class="lit">2</span><span class="lit">1</span><span class="lit">8</span><span class="lit">7</span><span class="lit">9</span><span class="lit">6</span><span class="lit">3</span><span class="lit">5</span><span class="lit">6</span><span class="kwd">%</span>&nbsp</code>
Which for our little algorithm whipped up in a couple of minutes isn't too bad, especially since the algorithm is for names and less than 30% of the words in the list names, we can say it was almost successful, but heavily not recommend for real-world situations.</br>
We can also conclude that it only made <code inline="true">76538</code> unique numbers, of which is actually very bad for our use case since the largest result index was <code inline="true">6.868313676231082e+30</code>.</br>
However, it is still important to remember that this is still a much better result than our first hashing algorithm of which couldn't even index an eight-character string let alone a 10.</br>
Also, our first algorithm given the same problem has only <code inline="true">1.176%</code> collision rate, but we cannot actually store any reasonable size strings.</p><break></break><p>
All in all, you can see why it is valuable to have specific case-based hashing functions.</br>
Possible solutions to some of the problems we have seen are using hashing to predict the location but also storing the key along with the data, thus if a collision occurs the new value can be stored in the next empty index, of which can then be searched for when the predicted location does not match. Thus, you can get the speedups of hashing while still storing a large variety of key values.</br></p><p>
Another possible solution which can cause unpredictable results is training a recursive neural network of example keys to generate values that do not conflict with one another but still use the smallest amount of indexes possible. This effect is like the freeloading of a general solution of which may not always work and will increase initial index prediction processing.</p><a name="Foot Note" class="target" href="#Foot Note" style="text-decoration:none;"><h2>Foot Note</h2></a><p>
If you are woundering why there is such a large collision rate with an algorithum that appears to not collide with regular words; it is because of number overflows.</br>
If we make a generic algorithm for how many bytes will be needed to store a decimal value based off of string length;
<code type="eq"><span class="row"><span class="pow"><span class="base"><span class="char">2</span><span class="char">4</span></span><sup><span class="char">l</span><span class="char">e</span><span class="char">n</span><span class="char">g</span><span class="char">t</span><span class="char">h</span></sup></span><span class="opper">÷</span><span class="char">b</span><span class="char">y</span><span class="char">t</span><span class="char">e</span><span class="char">s</span></span><span class="row"></span></code>
So to overflow a 32bit number you only need a length of;
<code type="eq"><span class="row"><span class="pow"><span class="base"><span class="char">2</span><span class="char">4</span></span><sup><span class="char">l</span><span class="char">e</span><span class="char">n</span><span class="char">g</span><span class="char">t</span><span class="char">h</span></sup></span><span class="opper">÷</span><span class="char">b</span><span class="char">y</span><span class="char">t</span><span class="char">e</span><span class="char">s</span><span class="char">≥</span><span class="char">4</span></span><span class="row"><span class="pow"><span class="base"><span class="char">2</span><span class="char">4</span></span><sup><span class="char">l</span><span class="char">e</span><span class="char">n</span><span class="char">g</span><span class="char">t</span><span class="char">h</span></sup></span><span class="char">≥</span><span class="char">4</span><span class="opper">×</span><span class="char">b</span><span class="char">y</span><span class="char">t</span><span class="char">e</span><span class="char">s</span></span><span class="row"><span class="char">l</span><span class="char">e</span><span class="char">n</span><span class="char">g</span><span class="char">t</span><span class="char">h</span><span class="opper">×</span><span class="char">l</span><span class="char">o</span><span class="char">g</span>(<span class="char">2</span><span class="char">4</span>)<span class="opper">=</span><span class="char">l</span><span class="char">o</span><span class="char">g</span>(<span class="char">4</span>)<span class="opper">+</span><span class="char">l</span><span class="char">o</span><span class="char">g</span>(bytes)</span><span class="row"><span class="char">l</span><span class="char">e</span><span class="char">n</span><span class="char">g</span><span class="char">t</span><span class="char">h</span><span class="opper">=</span>(<span class="char">l</span><span class="char">o</span><span class="char">g</span>(<span class="char">4</span>)<span class="opper">+</span><span class="char">l</span><span class="char">o</span><span class="char">g</span>(<span class="char">b</span><span class="char">y</span><span class="char">t</span><span class="char">e</span><span class="char">s</span>))<span class="opper">÷</span><span class="char">l</span><span class="char">o</span><span class="char">g</span>(24)</span><span class="row"></span></code></p><break></break><a name="References" class="target" href="#References" style="text-decoration:none;"><h2>References</h2></a><p><ol><li>James Curran (NCSS)</li></ol></p><a name="Related" class="target" href="#Related" style="text-decoration:none;"><h2>Related</h2></a><p><ul><li><a href="/p/5.html">Appendix: Key VS Value Hashing</a></li></ul></p><span class="tags"><h6 style="display: inline-block;">Tags:</h6><a href="/t/IPT.html"><tag>IPT;</tag></a></span></div><footer>
	<a href="https://goo.gl/forms/8wgwU9mPZlKogDEn2">Feedback</a>
	<a href="/feed.rss" style="float:right">RSS Feed</a>
</footer></body>
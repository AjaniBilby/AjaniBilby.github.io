<head><title>Buddy Memory Allocation</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#24292e">

<link rel="stylesheet" type="text/css" href="/style/main.css">
<link rel="stylesheet" type="text/css" href="/style/head.css">
<link rel="stylesheet" type="text/css" href="/style/footer.css">
<link rel="stylesheet" type="text/css" href="/style/article.css">
<link rel="stylesheet" type="text/css" href="/style/snippet.css"></head><body><header>
  <a href="/index.html">Home</a>
  <a href="/p/me.html" style="float: right;">Ajani James Bilby</a>
</header><div class="wrapper"><h1>Buddy Memory Allocation</h1><p>
A regularly used method for allocating space within a fixed region is <b>Buddy Memory Allocation</b>.
This system works like a tree, where each branch either has boolean value, or branches to another set of the same.</p><p>
<table>
<tr>
  <td>8</td>
</tr>
<tr>
  <td>4</td><td>4</td>
</tr>
<tr>
 <td>2</td><td>2</td><td>2</td><td>2</td>
</tr>
<tr>
  <td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td>
<tr>
<table></p><p>
This means that when you allocated large chuncks, or there are multiple chuncks allocated next to eachother they can merge branches into a single value of true, thus saving memory and compute time since there is no point testing all of the branches if it is already know that they are all true.</p><break></break><a name="Defining"><h2>Defining</h2></a><p>
First of all we need to setup a branch class, since we will have any interlinking entities of this structure and behaviour.</p><p>
<b>A</b> & <b>B</b>: Are both branches of the current fork <code inline="true">BMA</code>.</br>
<b>Size</b>: Is the area of which each sub branch will cover.
<code><span class="typ">class</span>&nbspBMA{<br>&nbsp&nbsp<span class="cal">constructor</span>(parent&nbsp<span class="kwd">=</span>&nbspnull,&nbspsize&nbsp<span class="kwd">=</span>&nbsp<span class="lit">8</span>){<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.parent&nbsp<span class="kwd">=</span>&nbspparent;<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.a&nbsp<span class="kwd">=</span>&nbsp<span class="lit">false</span>;<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.b&nbsp<span class="kwd">=</span>&nbsp<span class="lit">false</span>;<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.size&nbsp<span class="kwd">=</span>&nbspsize;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="cal">get</span>(start,&nbspend){}<br>&nbsp&nbsp<span class="cal">set</span>(start,&nbspend){}<br><br>&nbsp&nbsp<span class="cal">merge</span>(target){}<br><br>&nbsp&nbsp<span class="cal">find</span>(val,&nbsplength){}<br>}</code></p><a name="Defining"><h2>Defining</h2></a><p>
First of all we need to enforce a boolean type to val, as well as calculation the actual size of the allocation being requested.
<code><span class="cal">set</span>(start,&nbspend){<br>&nbsp&nbspval&nbsp<span class="kwd">=</span>&nbsp(val&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="lit">true</span>);<br>&nbsp&nbsp<span class="typ">let</span>&nbspsize&nbsp<span class="kwd">=</span>&nbspe&nbsp<span class="kwd">-</span>&nbsps;<br><br>&nbsp&nbsp<span class="com">//...</span></code></p><p>
If the value will overwrite an entire branch then, all we need to do is set the branch value to <code inline="true">val</code>.</br>
Also if this change make both branches the same, then there is no point in the divide exising, so we should tell the parent that this path should just be <code inline="true">val</code>.
<code>&nbsp&nbsp<span class="com">//...</span><br><br>&nbsp&nbsp<span class="com">//Fills&nbspsect&nbspA</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(s&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="lit">0</span>&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbspe&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="spe">this</span>.size){<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.a&nbsp<span class="kwd">=</span>&nbspval;<br><br>&nbsp&nbsp&nbsp&nbsp<span class="com">//&nbspThere&nbspis&nbspno&nbspreason&nbspfor&nbspthis&nbspbranch&nbspto&nbspexist&nbspanymore</span><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.b&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbspval&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbsp<span class="spe">this</span>.parent){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.parent.<span class="cal">merge</span>(<span class="spe">this</span>);<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="com">//End&nbspexecution&nbspsince&nbspthe&nbspdesired&nbspsection&nbsponly&nbspfills&nbspthis&nbspspace.</span><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp<span class="spe">this</span>;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="com">//Fills&nbspsect&nbspB</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(s&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="spe">this</span>.size&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbspe&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="spe">this</span>.size&nbsp<span class="kwd">+</span>&nbsp<span class="spe">this</span>.size){<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.b&nbsp<span class="kwd">=</span>&nbspval;<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.a&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbspval&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbsp<span class="spe">this</span>.parent){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.parent.<span class="cal">merge</span>(<span class="spe">this</span>);<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp<span class="spe">this</span>;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="com">//...</span></code></p><p>
Now we need to handel the complex issus of when a request only partly fills a part of a branch/s. We need to test if he request is touches each branch, and then casecade the set opperation down the tree until it completely fills a section/s.</br>
We also need to keep inmind what the branche's previouse value was, because that is what all new subsiquent branches value should be, unless it is overwritten by the new set operation.</br>
<code>&nbsp&nbsp<span class="com">//...</span><br><br>&nbsp&nbsp<span class="com">//&nbspCollides&nbspwith&nbspsect&nbspA,&nbspand&nbspis&nbspchanging&nbspa&nbspvalue</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(s&nbsp<span class="kwd">&</span>lt&nbsp<span class="spe">this</span>.size&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbsp<span class="spe">this</span>.a&nbsp<span class="kwd">!</span><span class="kwd">=</span>&nbspval){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="kwd">!</span>(<span class="spe">this</span>.a&nbspinstanceof&nbspBMA)){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="typ">let</span>&nbspwas&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.a;<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.a&nbsp<span class="kwd">=</span>&nbsp<span class="kwd">new</span>&nbsp<span class="cal">BMA</span>(<span class="spe">this</span>,&nbsp<span class="spe">this</span>.size/<span class="lit">2</span>);&nbsp<span class="com">//&nbspCreate&nbspa&nbspnew&nbspsub&nbspbranch</span><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.a.a&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.a.b&nbsp<span class="kwd">=</span>&nbspwas;&nbsp<span class="com">//&nbspApply&nbspthe&nbspold&nbspvalue&nbspto&nbspthe&nbspdefault&nbspvalue&nbspof&nbspthe&nbspnew&nbspbranches</span><br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="com">//&nbspConfine&nbspthe&nbsprange&nbspto&nbspfit&nbspwithin&nbspthe&nbspsub-branch,&nbspand&nbspparse&nbspthe&nbspvalue&nbspdown&nbspthe&nbsptree.</span><br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.a.<span class="cal">set</span>(s,&nbspMath.<span class="cal">min</span>(<span class="spe">this</span>.size,&nbspe),&nbspval);<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="com">//&nbspCollides&nbspwith&nbspsect&nbspB,&nbspand&nbspis&nbspchaning&nbspa&nbspvalue</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(e&nbsp<span class="kwd">&</span>gt&nbsp<span class="spe">this</span>.size&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbsp<span class="spe">this</span>.b&nbsp<span class="kwd">!</span><span class="kwd">=</span>&nbspval){<br>&nbsp&nbsp&nbsp&nbsps&nbsp<span class="kwd">-</span><span class="kwd">=</span>&nbsp<span class="spe">this</span>.size;<br>&nbsp&nbsp&nbsp&nbspe&nbsp<span class="kwd">-</span><span class="kwd">=</span>&nbsp<span class="spe">this</span>.size;<br><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="kwd">!</span>(<span class="spe">this</span>.b&nbspinstanceof&nbspBMA)){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="typ">let</span>&nbspwas&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.b;<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.b&nbsp<span class="kwd">=</span>&nbsp<span class="kwd">new</span>&nbsp<span class="cal">BMA</span>(<span class="spe">this</span>,&nbsp<span class="spe">this</span>.size/<span class="lit">2</span>);<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.b.a&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.b.b&nbsp<span class="kwd">=</span>&nbspwas;<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.b.<span class="cal">set</span>(Math.<span class="cal">max</span>(<span class="lit">0</span>,&nbsps),&nbspe,&nbspval);<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="com">//...</span></code></p><p>
Now we just need a final check to run to make sure that if this set caused merging of branches, that it actually continues it's way up the tree.
<code>&nbsp&nbsp<span class="com">//...</span><br><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.parent&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbsp<span class="spe">this</span>.a<span class="kwd">=</span><span class="kwd">=</span><span class="spe">this</span>.b){<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.parent.<span class="cal">merge</span>(<span class="spe">this</span>);<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="kwd">return</span>;<br>}</code></p><break></break><p>
<a href="https://github.com/Hobgoblin101/Hobgoblin101.github.io/tree/master/code/9">code</a></p><span class="tags"><h6 style="display: inline-block;">Tags:</h6><a href="/t/Data-Structure.html"><tag>Data-Structure;</tag></a><a href="/t/IPT.html"><tag>IPT;</tag></a></span></article></div><footer>
  <a href="https://goo.gl/forms/8wgwU9mPZlKogDEn2">Feedback</a>
  <a href="/feed.rss" style="float:right">RSS Feed</a>
</footer></body>
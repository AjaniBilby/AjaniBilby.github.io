<head><title>Buddy Memory Allocation</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#d81b60">

<link rel="stylesheet" type="text/css" href="/style/main.css">

<script src="/script/main.js"></script></head><body><header>
	<a href="/index.html" style="float: left;">Home</a>
	<a href="/feed.html" style="float: left;">Feed</a>
	<a href="/p/me.html" style="float: right;">Ajani James Bilby</a>
</header><div class="wrapper"><h1>Buddy Memory Allocation</h1><p>
A regularly used method for allocating space within a fixed region is <b>Buddy Memory Allocation</b>.
This system works like a tree, where each branch either has a boolean value or branches to another set of the same.</p><p>
<table>
<tr>
  <td>8</td>
</tr>
<tr>
  <td>4</td><td>4</td>
</tr>
<tr>
 <td>2</td><td>2</td><td>2</td><td>2</td>
</tr>
<tr>
  <td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td>
<tr>
<table></p><p>
This means that when you allocated large chunks, or there are multiple chunks allocated next to each other they can merge branches into a single value of true, thus saving memory and compute time since there is no point testing all of the branches if it is already know that they are all true.</p><break></break><a name="Defining" class="target" href="#Defining" style="text-decoration:none;"><h2>Defining</h2></a><p>
First of all, we need to set up a branch class since we will have any interlinking entities of this structure and behaviour.</p><p>
<b>A</b> & <b>B</b>: Are both branches of the current fork <code inline="true">BMA</code>.</br>
<b>Size</b>: Is the area of which each sub-branch will cover.
<code><span class="typ">class</span>&nbspBMA{<br>&nbsp&nbsp<span class="cal">constructor</span>(parent&nbsp<span class="kwd">=</span>&nbspnull,&nbspsize&nbsp<span class="kwd">=</span>&nbsp<span class="lit">8</span>){<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.parent&nbsp<span class="kwd">=</span>&nbspparent;<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.a&nbsp<span class="kwd">=</span>&nbsp<span class="lit">false</span>;<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.b&nbsp<span class="kwd">=</span>&nbsp<span class="lit">false</span>;<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.size&nbsp<span class="kwd">=</span>&nbspsize;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="cal">get</span>(start,&nbspend){}<br>&nbsp&nbsp<span class="cal">set</span>(start,&nbspend){}<br><br>&nbsp&nbsp<span class="cal">merge</span>(target){}<br><br>&nbsp&nbsp<span class="cal">find</span>(val,&nbsplength){}<br>}</code></p><a name="Defining" class="target" href="#Defining" style="text-decoration:none;"><h2>Defining</h2></a><p>
First of all, we need to enforce a boolean type to value, as well as calculation the actual size of the allocation being requested.
<code><span class="cal">set</span>(start,&nbspend){<br>&nbsp&nbspval&nbsp<span class="kwd">=</span>&nbsp(val&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="lit">true</span>);<br>&nbsp&nbsp<span class="typ">let</span>&nbspsize&nbsp<span class="kwd">=</span>&nbspe&nbsp<span class="kwd">-</span>&nbsps;<br><br>&nbsp&nbsp<span class="com">//...</span></code></p><p>
If the value will overwrite an entire branch then, all we need to do is set the branch value to <code inline="true">val</code>.</br>
Also if this change makes both branches the same, then there is no point in the divide existing, so we should tell the parent that this path should just be <code inline="true">val</code>.
<code>&nbsp&nbsp<span class="com">//...</span><br><br>&nbsp&nbsp<span class="com">//Fills&nbspsect&nbspA</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(s&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="lit">0</span>&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbspe&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="spe">this</span>.size){<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.a&nbsp<span class="kwd">=</span>&nbspval;<br><br>&nbsp&nbsp&nbsp&nbsp<span class="com">//&nbspThere&nbspis&nbspno&nbspreason&nbspfor&nbspthis&nbspbranch&nbspto&nbspexist&nbspanymore</span><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.b&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbspval&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbsp<span class="spe">this</span>.parent){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.parent.<span class="cal">merge</span>(<span class="spe">this</span>);<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="com">//End&nbspexecution&nbspsince&nbspthe&nbspdesired&nbspsection&nbsponly&nbspfills&nbspthis&nbspspace.</span><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp<span class="spe">this</span>;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="com">//Fills&nbspsect&nbspB</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(s&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="spe">this</span>.size&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbspe&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="spe">this</span>.size&nbsp<span class="kwd">+</span>&nbsp<span class="spe">this</span>.size){<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.b&nbsp<span class="kwd">=</span>&nbspval;<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.a&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbspval&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbsp<span class="spe">this</span>.parent){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.parent.<span class="cal">merge</span>(<span class="spe">this</span>);<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp<span class="spe">this</span>;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="com">//...</span></code></p><p>
Now we need to handle the complex issues of when a request only partly fills a part of a branch/s. We need to test if the request is touching each branch, and then cascade the set operation down the tree until it completely fills a section/s.</br>
We also need to keep in mind what the branches previous value was because that is what all new subsequent branches value should be unless it is overwritten by the new set operation.</br>
<code>&nbsp&nbsp<span class="com">//...</span><br><br>&nbsp&nbsp<span class="com">//&nbspCollides&nbspwith&nbspsect&nbspA,&nbspand&nbspis&nbspchanging&nbspa&nbspvalue</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(s&nbsp<span class="kwd">&lt</span>&nbsp<span class="spe">this</span>.size&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbsp<span class="spe">this</span>.a&nbsp<span class="kwd">!</span><span class="kwd">=</span>&nbspval){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="kwd">!</span>(<span class="spe">this</span>.a&nbspinstanceof&nbspBMA)){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="typ">let</span>&nbspwas&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.a;<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.a&nbsp<span class="kwd">=</span>&nbsp<span class="kwd">new</span>&nbsp<span class="cal">BMA</span>(<span class="spe">this</span>,&nbsp<span class="spe">this</span>.size/<span class="lit">2</span>);&nbsp<span class="com">//&nbspCreate&nbspa&nbspnew&nbspsub&nbspbranch</span><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.a.a&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.a.b&nbsp<span class="kwd">=</span>&nbspwas;&nbsp<span class="com">//&nbspApply&nbspthe&nbspold&nbspvalue&nbspto&nbspthe&nbspdefault&nbspvalue&nbspof&nbspthe&nbspnew&nbspbranches</span><br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="com">//&nbspConfine&nbspthe&nbsprange&nbspto&nbspfit&nbspwithin&nbspthe&nbspsub-branch,&nbspand&nbspparse&nbspthe&nbspvalue&nbspdown&nbspthe&nbsptree.</span><br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.a.<span class="cal">set</span>(s,&nbspMath.<span class="cal">min</span>(<span class="spe">this</span>.size,&nbspe),&nbspval);<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="com">//&nbspCollides&nbspwith&nbspsect&nbspB,&nbspand&nbspis&nbspchaning&nbspa&nbspvalue</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(e&nbsp<span class="kwd">&gt</span>&nbsp<span class="spe">this</span>.size&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbsp<span class="spe">this</span>.b&nbsp<span class="kwd">!</span><span class="kwd">=</span>&nbspval){<br>&nbsp&nbsp&nbsp&nbsps&nbsp<span class="kwd">-</span><span class="kwd">=</span>&nbsp<span class="spe">this</span>.size;<br>&nbsp&nbsp&nbsp&nbspe&nbsp<span class="kwd">-</span><span class="kwd">=</span>&nbsp<span class="spe">this</span>.size;<br><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="kwd">!</span>(<span class="spe">this</span>.b&nbspinstanceof&nbspBMA)){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="typ">let</span>&nbspwas&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.b;<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.b&nbsp<span class="kwd">=</span>&nbsp<span class="kwd">new</span>&nbsp<span class="cal">BMA</span>(<span class="spe">this</span>,&nbsp<span class="spe">this</span>.size/<span class="lit">2</span>);<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.b.a&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.b.b&nbsp<span class="kwd">=</span>&nbspwas;<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.b.<span class="cal">set</span>(Math.<span class="cal">max</span>(<span class="lit">0</span>,&nbsps),&nbspe,&nbspval);<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="com">//...</span></code></p><p>
Now we just need a final check to run to make sure that if this set caused merging of branches, that it actually continues it's way up the tree.
<code>&nbsp&nbsp<span class="com">//...</span><br><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.parent&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbsp<span class="spe">this</span>.a<span class="kwd">=</span><span class="kwd">=</span><span class="spe">this</span>.b){<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.parent.<span class="cal">merge</span>(<span class="spe">this</span>);<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="kwd">return</span>;<br>}</code></p><break></break><a name="Getting" class="target" href="#Getting" style="text-decoration:none;"><h2>Getting</h2></a><p>
There is no point to define anything if you can't read the information back.</br>
Since the request can expose a large section of the allocation information it means that the total value over the range can be a mix of true and false.</br>
Thus instead of returning true and false from this function, we will instead return 1, and -1, respectively, using 0 to mean that the area is a mix of both.</p><p>
When the request is entirely within only one section.
<code>get&nbsp(s,&nbspe){<br><br>&nbsp&nbsp<span class="com">//&nbspOnly&nbspin&nbspsect&nbspA</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(s&nbsp<span class="kwd">&lt</span>&nbsp<span class="spe">this</span>.size&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbspe&nbsp<span class="kwd">&lt</span><span class="kwd">=</span>&nbsp<span class="spe">this</span>.size){<br>&nbsp&nbsp&nbsp&nbsp<span class="com">//&nbspIf&nbspa&nbspis&nbspanother&nbspbranch,&nbspthen&nbspparse&nbspforward&nbspthe&nbsprequest</span><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.a&nbspinstanceof&nbspBMA){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp<span class="spe">this</span>.a.<span class="cal">get</span>(s,&nbspe);<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="com">//&nbspIf&nbspa&nbspis&nbsptrue&nbspreturn&nbsp1,&nbspelse&nbspreturn&nbsp-1</span><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp<span class="spe">this</span>.a&nbsp?&nbsp<span class="lit">1</span>&nbsp:&nbsp<span class="kwd">-</span><span class="lit">1</span>;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="com">//&nbspOnly&nbspin&nbspsect&nbspB</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(s&nbsp<span class="kwd">&gt</span>&nbsp<span class="spe">this</span>.size){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.b&nbspinstanceof&nbspBMA){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp<span class="spe">this</span>.b.<span class="cal">get</span>(<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsps<span class="kwd">-</span><span class="spe">this</span>.size,&nbsp<span class="com">//Make&nbspthe&nbsppointers&nbsprelative</span><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspe<span class="kwd">-</span><span class="spe">this</span>.size<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp);<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp<span class="spe">this</span>.b&nbsp?&nbsp<span class="lit">1</span>&nbsp:&nbsp<span class="kwd">-</span><span class="lit">1</span>;<br>&nbsp&nbsp}<br><br><span class="com">//...</span></code></p><p>
Now we need to write a case for if the request covers at least some of both branches.</br>
This means we need to test the composition of which covers each branch, and if the two values don't match then return 0, otherwise we can just return their shared value.</br></p><blockquote><p>Remember, if one branch is a mix of both values there is no point in testing the value of the other since any possible combination will also just result in a mix of the two.
</p></blockquote><p><code><span class="com">//...</span><br><br>&nbsp&nbsp<span class="typ">let</span>&nbspa&nbsp<span class="kwd">=</span>&nbspnull;<br>&nbsp&nbsp<span class="typ">let</span>&nbspb&nbsp<span class="kwd">=</span>&nbspnull;<br><br>&nbsp&nbsp<span class="com">//&nbspIf&nbspthe&nbsprequest&nbspcollides&nbspwith&nbspbranch&nbspA</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(s&nbsp<span class="kwd">&lt</span>&nbsp<span class="spe">this</span>.size){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.a&nbspinstanceof&nbspBMA){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspa&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.a.<span class="cal">get</span>(<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsps,<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspMath.<span class="cal">min</span>(<span class="spe">this</span>.size,&nbspe)&nbsp<span class="com">//&nbspEnsure&nbspthat&nbspthe&nbspparsed&nbspend&nbsppointer&nbspisn't&nbspgoing&nbspout&nbspof&nbspthe&nbspbranch</span><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp);<br>&nbsp&nbsp&nbsp&nbsp}<span class="kwd">else</span>{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspa&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.a&nbsp?&nbsp<span class="lit">1</span>&nbsp:&nbsp<span class="kwd">-</span><span class="lit">1</span>;<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(a&nbsp<span class="kwd">=</span><span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="lit">0</span>){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp<span class="lit">0</span>;<br>&nbsp&nbsp&nbsp&nbsp}<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="com">//&nbspIf&nbspthe&nbsprequest&nbspcollides&nbspwith&nbspbranch&nbspB</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(e&nbsp<span class="kwd">&gt</span>&nbsp<span class="spe">this</span>.size){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.b&nbspinstanceof&nbspBMA){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspb&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.b.<span class="cal">get</span>(s<span class="kwd">-</span><span class="spe">this</span>.size,&nbspe<span class="kwd">-</span><span class="spe">this</span>.size);<br>&nbsp&nbsp&nbsp&nbsp}<span class="kwd">else</span>{<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspb&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.b&nbsp?&nbsp<span class="lit">1</span>&nbsp:&nbsp<span class="kwd">-</span><span class="lit">1</span>;<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(b&nbsp<span class="kwd">=</span><span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="lit">0</span>){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp<span class="lit">0</span>;<br>&nbsp&nbsp&nbsp&nbsp}<br>&nbsp&nbsp}<br><br><br><br>&nbsp&nbsp<span class="com">//&nbspIf&nbspone&nbspof&nbspthe&nbspbranches's&nbspdidn't&nbspactually&nbspcollide&nbspwith&nbspthe&nbsprequest</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(a&nbsp<span class="kwd">=</span><span class="kwd">=</span><span class="kwd">=</span>&nbspnull){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspb;<br>&nbsp&nbsp}<br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(b&nbsp<span class="kwd">=</span><span class="kwd">=</span><span class="kwd">=</span>&nbspnull){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspa;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(a&nbsp<span class="kwd">=</span><span class="kwd">=</span><span class="kwd">=</span>&nbspb){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspa;<br>&nbsp&nbsp}<span class="kwd">else</span>{<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp<span class="lit">0</span>;<br>&nbsp&nbsp}<br><br>}</code></p><break></break><a name="Finding space" class="target" href="#Finding space" style="text-decoration:none;"><h2>Finding space</h2></a><p>
There is no point to an allocation system if you can't find a space to put some data. So our request will just state the desired size.</br>
We will also make this function more versatile by allowing the request to specify the value it is trying to find, and thus how much space that value takes up.</br></p><p>
We also should always make sure that we return the tightest fitting space available because then it allows the bigger available spaces to be filled by future requests.</p><p>
<code>hit&nbsp(val,&nbspsize){<br>&nbsp&nbsp<span class="com">//&nbspThe&nbsprequest&nbspwon't&nbspfit,&nbspat&nbspthis&nbspdepth,&nbspso&nbspthere's&nbspno&nbsppoint</span><br>&nbsp&nbsp<span class="com">//&nbspChecking&nbspdeeper&nbspbranches&nbspsince&nbspthey&nbspwill&nbspjust&nbsphave&nbspless</span><br>&nbsp&nbsp<span class="com">//&nbspspace</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.size&nbsp<span class="kwd">&lt</span>&nbspsize){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspNaN;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="com">//&nbspIf&nbspthe&nbsprequest&nbspmatches&nbspan&nbspavailable&nbspbranch</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.a&nbsp<span class="kwd">=</span><span class="kwd">=</span><span class="kwd">=</span>&nbspval){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp{pos:&nbsp<span class="lit">0</span>,&nbspsize:&nbsp<span class="spe">this</span>.size}<br>&nbsp&nbsp}<span class="kwd">else</span>&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.b&nbsp<span class="kwd">=</span><span class="kwd">=</span><span class="kwd">=</span>&nbspval){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp{pos:&nbsp<span class="spe">this</span>.size,&nbspsize:&nbsp<span class="spe">this</span>.size}<br>&nbsp&nbsp}<br><br><br>&nbsp&nbsp<span class="typ">let</span>&nbspa&nbsp<span class="kwd">=</span>&nbspNaN;<br>&nbsp&nbsp<span class="typ">let</span>&nbspb&nbsp<span class="kwd">=</span>&nbspNaN;<br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.a&nbspinstanceof&nbspBMA){<br>&nbsp&nbsp&nbsp&nbspa&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.a.<span class="cal">hit</span>(val,&nbspsize);<br><br>&nbsp&nbsp&nbsp&nbsp<span class="com">//&nbspTight&nbspfit&nbspfound</span><br>&nbsp&nbsp&nbsp&nbsp<span class="com">//&nbspThere&nbspwill&nbspbe&nbspno&nbspbetter&nbspsolutions,&nbsponly&nbspequal&nbspbest</span><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(a&nbsp<span class="kwd">!</span><span class="kwd">=</span>&nbspNaN&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbspa.size&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbspsize){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspa;<br>&nbsp&nbsp&nbsp&nbsp}<br>&nbsp&nbsp}<br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="spe">this</span>.b&nbspinstanceof&nbspBMA){<br>&nbsp&nbsp&nbsp&nbspb&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.b.<span class="cal">hit</span>(val,&nbspsize);<br><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(b&nbsp<span class="kwd">!</span><span class="kwd">=</span>&nbspNaN&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbspa.size&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbspsize){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspb;<br>&nbsp&nbsp&nbsp&nbsp}<br>&nbsp&nbsp}<br><br><br>&nbsp&nbsp<span class="com">//&nbspIf&nbspan&nbspoption&nbspis&nbspNaN,&nbspthen&nbspreturn&nbspthe&nbspother&nbspoption</span><br>&nbsp&nbsp<span class="typ">let</span>&nbspna&nbsp<span class="kwd">=</span>&nbsp<span class="cal">isFinite</span>(a)&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbsp<span class="cal">isNaN</span>(a);<br>&nbsp&nbsp<span class="typ">let</span>&nbspnb&nbsp<span class="kwd">=</span>&nbsp<span class="cal">isFinite</span>(b)&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbsp<span class="cal">isNaN</span>(b);<br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(na&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbspnb){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspNaN;<br>&nbsp&nbsp}<br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(<span class="kwd">!</span>na&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbspnb){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspa;<br>&nbsp&nbsp}<br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(na&nbsp<span class="kwd">&</span><span class="kwd">&</span>&nbsp<span class="kwd">!</span>nb){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspb;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="com">//&nbspBoth&nbspoptions&nbspa&nbsp&&nbspb&nbspwill&nbspwork,</span><br>&nbsp&nbsp<span class="com">//&nbspSelect&nbspwhich&nbspever&nbspone&nbspis&nbspsmallest,</span><br>&nbsp&nbsp<span class="com">//&nbspPrioritising&nbspa</span><br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(a.size&nbsp<span class="kwd">&lt</span>&nbspb.size){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspa;<br>&nbsp&nbsp}<br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(b.size&nbsp<span class="kwd">&gt</span>&nbspa.size){<br>&nbsp&nbsp&nbsp&nbspb.pos&nbsp<span class="kwd">+</span><span class="kwd">=</span>&nbsp<span class="spe">this</span>.size;&nbsp<span class="com">//&nbspMake&nbspthe&nbsppos&nbsprelative&nbspto&nbspthis&nbspdepth</span><br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspb;<br>&nbsp&nbsp}<br>&nbsp&nbsp<span class="kwd">if</span>&nbsp(a.size&nbsp<span class="kwd">=</span><span class="kwd">=</span><span class="kwd">=</span>&nbspb.size){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbspa;<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="kwd">throw</span>&nbsp<span class="kwd">new</span>&nbsp<span class="cal">Error</span>()<br>}</code></p><p>
However, this allocation system doesn't automatically example it's self when necessary to write new data. This will add a new parent class to allow this.</p><p>
<code><span class="typ">class</span>&nbspBMAX{<br>&nbsp&nbsp<span class="cal">constructor</span>(length){<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.root&nbsp<span class="kwd">-</span>&nbsp<span class="kwd">new</span>&nbsp<span class="cal">BMA</span>();<br>&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.length&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.root.size&nbsp<span class="kwd">*</span><span class="lit">2</span>;<br>&nbsp&nbsp}<br><br>&nbsp&nbspset&nbsp(s,&nbspe,&nbspval){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp<span class="spe">this</span>.root.<span class="cal">set</span>(s,e,val);<br>&nbsp&nbsp}<br>&nbsp&nbspget&nbsp(s,e){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp<span class="spe">this</span>.root.<span class="cal">get</span>(s,e);<br>&nbsp&nbsp}<br>&nbsp&nbsp<span class="cal">find</span>(size,&nbspval){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">return</span>&nbsp<span class="spe">this</span>.root.<span class="cal">hit</span>(val&nbsp<span class="kwd">=</span><span class="kwd">=</span><span class="kwd">=</span>&nbsp<span class="lit">true</span>,&nbspsize);<br>&nbsp&nbsp}<br><br>&nbsp&nbsp<span class="cal">extend</span>(amount&nbsp<span class="kwd">=</span>&nbsp<span class="lit">1</span>){<br>&nbsp&nbsp&nbsp&nbsp<span class="typ">let</span>&nbspol&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.length;<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(amount&nbsp<span class="kwd">&lt</span>&nbsp<span class="lit">1</span>){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspamount&nbsp<span class="kwd">=</span>&nbsp<span class="lit">1</span>;<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbsp<span class="com">//&nbspMake&nbspthe&nbspcurrent&nbsproot&nbspinto&nbspa&nbspbranch&nbspof&nbspa&nbspnew&nbsproot</span><br>&nbsp&nbsp&nbsp&nbspw<span class="cal">hile</span>(<span class="spe">this</span>.length&nbsp<span class="kwd">-</span>&nbspol&nbsp<span class="kwd">&lt</span>&nbspamount){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="typ">let</span>&nbspt&nbsp<span class="kwd">=</span>&nbsp<span class="kwd">new</span>&nbsp<span class="cal">BMA</span>(undefined,&nbsp<span class="spe">this</span>.length);<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspt.a&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.root;<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspt.a.parent&nbsp<span class="kwd">=</span>&nbspt;<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.root&nbsp<span class="kwd">=</span>&nbspt;<br><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="spe">this</span>.length&nbsp<span class="kwd">=</span>&nbsp<span class="spe">this</span>.root.size<span class="kwd">*</span><span class="lit">2</span>;<br>&nbsp&nbsp&nbsp&nbsp}<br>&nbsp&nbsp}<br>}</code></p><p>
Now if the recursive search function doesn't return any results, we can tell the allocation table to expand, as well as expanding out initial storage location to now have space to put the new data.</p><break></break><p>
<a href="https://github.com/Hobgoblin101/Hobgoblin101.github.io/tree/master/code/9">code</a></p><span class="tags"><h6 style="display: inline-block;">Tags:</h6><a href="/t/Data-Structure.html"><tag>Data-Structure;</tag></a><a href="/t/IPT.html"><tag>IPT;</tag></a></span></div><footer>
	<a href="https://goo.gl/forms/8wgwU9mPZlKogDEn2">Feedback</a>
	<a href="/feed.rss" style="float:right">RSS Feed</a>
</footer></body>
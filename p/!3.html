<head><title>Relational Table DBMS</title><meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" type="text/css" href="/style/main.css">
<link rel="stylesheet" type="text/css" href="/style/head.css">
<link rel="stylesheet" type="text/css" href="/style/footer.css">
<link rel="stylesheet" type="text/css" href="/style/article.css">
<link rel="stylesheet" type="text/css" href="/style/snippet.css"></head><body><header>
  <a href="/index.html">Home</a>
  <a href="/p/me.html" style="float: right;">Ajani James Bilby</a>
</header><div class="wrapper"><h1>Relational Table DBMS</h1><p><b>Recommended:</b> <a href="/p/1.html">UTF-8 Encoding</a>; <a href="/p/2.html">Two's Complement Integer</a></p><p></p><blockquote><p>I will not be going into table/data encryption as well as distributed databases since they are another level of obscurity on top of the actual data storage<br>Also I will not be discussing a query language as part of this article<br></p></blockquote><p>
Tables are perceived as a two dimensional table, but they need to be stored as a one dimensional file while being both data efficient as well as performance optimal.</br></p><p>
A key factor that allows all modern databases to be extremely fast is knowing where the data is without reading the whole blob. This is done by restricting the size of attributes, thus if you want the value at index x, you just need to read a section of the blob;
<code type="eq"><span class="row"><span class="char">s</span><span class="char">t</span><span class="char">a</span><span class="char">r</span><span class="char">t</span><span class="opper">=</span><span class="char">x</span><span class="opper">Ã—</span><span class="char">s</span><span class="char">i</span><span class="char">z</span><span class="char">e</span></span><span class="row"><span class="char">e</span><span class="char">n</span><span class="char">d</span><span class="opper">=</span><span class="char">s</span><span class="char">t</span><span class="char">a</span><span class="char">r</span><span class="char">t</span><span class="opper">+</span><span class="char">s</span><span class="char">i</span><span class="char">z</span><span class="char">e</span></span><span class="row"></span></code></p><p>
</p><a name="Tuples, Rows and Records"><h2>Tuples, Rows and Records</h2></a><p>
These all mean basically the exact same thing within the context of a table structured database. If you are trying to store a list of shops, then each tuple would be an individual shop.</br>
Also we could define each shop as having the attributes;</p><p><table><tr><th>Name </th><th>Street </th><th>Suburb </th><th>City </th><th>State </th><th>Country </th></tr><tr><td style="text-align:right;">Bakery </td><td style="text-align:left;">32 Carp St </td><td style="text-align:left;">Bega </td><td style="text-align:left;">Bega </td><td style="text-align:left;">NSW </td><td style="text-align:left;">AUS </td></tr><tr><td style="text-align:right;">Pizza  </td><td style="text-align:left;">72 New Town Rd </td><td style="text-align:left;">Bega </td><td style="text-align:left;">Bega </td><td style="text-align:left;">NSW </td><td style="text-align:left;">AUS </td></tr></table></p><p>
</p><a name="Attributes"><h3>Attributes</h3></a><p></p><p>
Now that we have created a table with two tuples, how can we read each tuple, as well as store it?</br>
First of all we will need to define some attribute type;<ul><li><b>Float</b>: A signed number of which can include non whole numbers. Made up of 32Bits</li><li><b>Double</b>: A signed number of which can include non-while numbers as well as number impractical to be stored as ints <code inline="true">6*(10)^(56)</code></li><li><b>String</b>: An array of characters</li><li><b>Int</b>: An Integer value encoded using two's complement integer</li><ul><li><b>Int8</b>: An integer made up of 8 bits</li><li><b>Int16</b>: An integer made up of 16bits</li><li><b>Int32</b>: An integer made up of 32bits</li><li><b>Int64</b>: An integer made up of 64bits</li></ul><li><b>UInt</b>: A positive only integer value</li><ul><li><b>UInt8</b>: An unsigned integer made up of 8 bits</li><li><b>UInt16</b>: An unsigned integer made up of 16bits</li><li><b>UInt32</b>: An unsigned integer made up of 32bits</li><li><b>UInt64</b>: An unsigned integer made up of 64bits</li></ul><li><b>Boolean</b>: A true/false value of which takes up a whole byte since it is in the smallest dividsion of useable storage space.</li></ul></p><p>
Now that we know what types of values we can store we can set encoding types for attributes in our table.</p><p><table><tr><th>Attribute name </th><th>Type </th><th>Bytes </th></tr><tr><td style="text-align:right;">Name </td><td style="text-align:center;">String </td><td style="text-align:left;">50 </td></tr><tr><td style="text-align:right;">Street </td><td style="text-align:center;">String </td><td style="text-align:left;">100 </td></tr><tr><td style="text-align:right;">Suburb </td><td style="text-align:center;">String </td><td style="text-align:left;">50  </td></tr><tr><td style="text-align:right;">City  </td><td style="text-align:center;">String </td><td style="text-align:left;">50 </td></tr><tr><td style="text-align:right;">State </td><td style="text-align:center;">String </td><td style="text-align:left;">3 </td></tr><tr><td style="text-align:right;">Country </td><td style="text-align:center;">String </td><td style="text-align:left;">3 </td></tr></table></p><p></p><blockquote><p>Remember because we set a specific length for each string in bytes it will limit the number of characters able to be stored within the table.<br></p></blockquote><p>Which means you need to pay close attention to the behaviour of which you cut your string length too. Because if you cut the string at the byte level, you can create invalid characters where they are missing the required number of bytes they need.</br>
It is normally safeset to remove whole characters at the end of a string until it meets the required size limits.</p><p>
It is also important to write the data to the exact length required, thus if your string does not have enough characters to fill the attribute, their; A) Add trailing spaces at the end of your string which you can remove later, or B) add null characters (bytes with value 0) to the end of your string till it is the correct length.</br>
Adding null characters can create undesired behaviour if you are trying to transfer the data, since some systems (mostly older systems) interprete eight null bytes sequentually to mean the end of file / communication.</p><p>
</p><a name="Indexing"><h2>Indexing</h2></a><p>
Now that we have our tuple setup we can now read and write data.
However it is always best to first cache our table's tuple size;
<code>table.tupleSize&nbsp<span class="kwd">=</span>&nbsp<span class="lit">0</span>;<br><span class="kwd">for</span>&nbsp(attribute<span class="kwd">&nbspin&nbsp</span>table.attributes){<br>&nbsp&nbsptable.tupleSize&nbsp<span class="kwd">+</span><span class="kwd">=</span>&nbspattribute.size;<br>}</code>
Now that we have the tuple size we can write some pseudo code to find out where each section of data lies;
<code><span class="typ">function&nbsp</span>GetAttribute(index,&nbspfield){<br>&nbsp&nbsp<span class="typ">let&nbsp</span>start&nbsp<span class="kwd">=</span>&nbspindex<span class="kwd">*</span>table.tupleSize;<br>&nbsp&nbsp<span class="typ">let&nbsp</span><span class="kwd">end</span>&nbsp<span class="kwd">=</span>&nbsp<span class="lit">0</span>;<br><br>&nbsp&nbsp<span class="kwd">for</span>&nbsp(attribute<span class="kwd">&nbspin&nbsp</span>table.attributes){<br>&nbsp&nbsp&nbsp&nbsp<span class="kwd">if</span>&nbsp(attribute.name&nbsp<span class="kwd">=</span><span class="kwd">=</span>&nbspfield){<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="kwd">end</span>&nbsp<span class="kwd">=</span>&nbspstart&nbsp<span class="kwd">+</span>&nbspattribute.size;<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<span class="kwd">return&nbsp</span>{start,&nbsp<span class="kwd">end</span>};<br>&nbsp&nbsp&nbsp&nbsp}<br><br>&nbsp&nbsp&nbsp&nbspstart&nbsp<span class="kwd">+</span><span class="kwd">=</span>&nbspattribute.size<br>&nbsp&nbsp}<br>}<br><br><span class="typ">function&nbsp</span>GetTuple(index){<br>&nbsp&nbspstart&nbsp<span class="kwd">=</span>&nbspindex<span class="kwd">*</span>table.tupleSize;<br>&nbsp&nbsp<span class="kwd">end</span>&nbsp<span class="kwd">=</span>&nbspstart&nbsp<span class="kwd">+</span>&nbsptable.tupleSize;<br><br>&nbsp&nbsp<span class="kwd">return&nbsp</span>{start,&nbsp<span class="kwd">end</span>}<br>}</code></p><p>
Now we can used this functions to write specific attributes, and also read them.</br></p><blockquote><p>It is normally best to read and entire tuple at a time, then once the tuple is in memory read each attribute. This is due to the fact that normally you want to get more that one attribute at a time, and having many file system requsts open at once for adjacent data puts unneccessary stress on your OS.<br></p></blockquote><p>
</p><a name="Tuple Key/s"><h2>Tuple Key/s</h2></a><p>
You may of noticed that allot of databases have special attributes called primary or composit keys.</br>
If you are using indirect referencing, then when you try and get an attribute by it's key, say <code inline="true">ID=64</code>.</br>
Then your DBMS will need to read though every single tuple until it finds one with <code inline="true">ID=64</code>.</p><blockquote><p>Finding tuples based on keys is a good use for specific attribute reading, instead of whole tuple reading<br></p></blockquote><p>
While exact indexing is highly performant sometimes keyed tuples is a better strategy.</br>
This is due to the fact that tuples can be deleted. When a tuple is deleted the entire tuple has null bytes written to fill it's place. This is done so the entire table from that record onwards does not need to be rewritten. Instead this task it seperated to be a different process known as compacting an repairing.</p><p>
</p><a name="Compact / Repairing a table"><h3>Compact / Repairing a table</h3></a><p>
As previously stated when records are 'deleted' they are overwritten with null bytes, what this process does, is it scans though the table to find these empty rows, when it shifts all records after it up one to fill the space. Thus the length of the entire table is now shorter since it won't have blank spaces where deleted records used to be.</br>
The major down side of this is that it then breaks any references.</br></p><blockquote><p>Don't forget to delete any references to a tuple when deleting it.<br></p></blockquote><p>
Let's say that you have a table which is a list of your friends, then another table of which has only two attributes of which are exact references to each member in a friendship.</br>
If these references are exact references, then if you remove a person from your list of friends, then compact the table, all references to people below the person that was removed will not be wrong, instead of pointing to the correct person, they will be pointing one person down from before.</p><p>
</p><a name="Solutions"><h4>Solutions</h4></a><p>
<b>Never delete any records</b></br>
Which is generally a bad solution since it means that your friends list would end up being completely oversize after you make and lose friendships</p><p>
<b>Fill in empty rows</b>
Never run a compacting algorithum on your table, and instead leave rows blank, then when it comes to adding a new person to your friends list, they fill up a previously empty row. This will mean that you will end up with empty rows in your table, but as long as you average around the space number of friends there will never be too many empty rows.</p><span class="tags"><h6 style="display: inline-block;">Tags:</h6><a href="/t/Data-Structure.html"><tag>Data-Structure;</tag></a><a href="/t/IPT.html"><tag>IPT;</tag></a></span></article></div><footer>
  <a href="https://goo.gl/forms/8wgwU9mPZlKogDEn2">Feedback</a>
</footer></body>